<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" ?>
<casaxml xmlns="http://casa.nrao.edu/schema/psetTypes.html"
	 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	 xsi:schemaLocation="http://casa.nrao.edu/schema/casa.xsd
			     file:///opt/casa/code/tools/xml/casa.xsd">
  
  
  
  
<tool name="simulator" module="simulator">
  <shortdescription>Tool for simulation</shortdescription>
  
  <code>
    <include>tools/synthesis/simulator_forward.h</include>
    <private>
	    <include>tools/synthesis/simulator_private.h</include>
    </private>
  </code>
  
  
  
  
<description> 
  
  {\tt simulator} provides a unified interface for simulation of
  telescope processing. It can create a MeasurementSet from scratch or
  read in an existing MeasurementSet, it can predict synthesis data onto
  the (u,v) coordinates or single dish data onto (ra,dec) points, and it
  can corrupt this data through Gaussian errors or through specific
  errors residing in (anti-) calibration tables.
  
  
  In the observing phase, {\tt simulator} tries to act like a
  (simple) telescope. You first make a {\tt simulator} tool, with the
  name of the MeasurementSet that you wish to construct. Next you use
  the various {\tt set*} methods to set up the observing (sources,
  spectral windows, {\em etc.}). Each such setup should be given a
  unique name that will be used in the next step. Then you call the {\tt
  observe} method for each observing scan you wish to make. Here you
  specify the source name, spectral windoow name, and observing
  times. After this, you have a MeasurementSet that is complete but
  empty. In the next phase, you fill the MeasurementSet with data from a
  model and then corrupt the measurements (if desired). To fill it in
  with a model, use the predict method. Finally, to apply errors, first
  set up the various effects using the relevant {\tt set*} methods, and
  then call corrupt.
  
  Some important points (mostly for the {\em cognoscenti}):
  \begin{itemize}
  \item One call to {\tt observe} generates one scan (all rows have
  the same SCAN\_NUMBER).
  \item The start and stop times specified to {\tt observe} need not be
  contiguous and so one can simulate antenna drive times.
  \item Currently there is no facility for patterns of observing, such
  as mosaicing, since it is easy to do this via sequences of calls of
  {\tt observe}.
  \item The heavy duty columns (DATA, FLAG, IMAGING\_WEIGHT, {\em etc.}
  are tiled. New tiles are generated for each scan. Thus the TSM files
  will not get very large.
  \end{itemize}
  
  {\tt simulator} changes some columns to the MeasurementSet to store
  results of processing. The following columns in the MS are
  particularly important:
  \begin{description}
  \item[DATA] The original observed visibilities are in a column
  called DATA. These are normally not altered by any processing in
  \aipspp. However, this simulation program does overwrite these
  values.
  \item[CORRECTED\_DATA] During a calibration process, as carried out by
  {\em e.g.} <link anchor="calibrater">calibrater</link>, the visibilities may be
  corrected for calibration effects. This corrected visibilities are
  stored in a column CORRECTED\_DATA which is created on demand.
  \item[MODEL\_DATA] During various phases of processing, the
  visibilities as predicted from some model are required. These 
  model visibilities are stored in a column MODEL\_DATA. The 
  <link anchor="imager:imager.ft.function">ft</link> function of the <link anchor="imager:imager">imager</link>
  tool should be used to calculate the model visibility for a
  model image or <link anchor="componentmodels">componentmodels</link>.
  \end{description}
  
  Standard tools such as the <link anchor="table">table</link> module and the
  <link anchor="ms">ms</link> can be used to access and possibly change these (and
  all other) columns.
  
  
  
  
  
  
  simulator is a tool that performs simulation of synthesis data, including
  (optionally) creation of a MeasurementSet, prediction of model data, and
  corruption by various physical effects.
</description>
  
  
  
  
<method type="constructor" name="simulator">
  <shortdescription>Construct a simulator tool</shortdescription>
  <description>
    Create a {\tt simulator} tool.
  </description>
  <returns type="simulatorobject">simulator tool</returns>
  <example>
    
    # create a simulator tool
    mysim = simulator();
    
  </example>
</method>  



<method type="function" name="open">
  <shortdescription>Construct a simulator tool and creating a new MeasurementSet</shortdescription>
  <description>
    This is used to construct {\tt simulator} tools.  A simulator tool
    can either be instantiated from an existing MeasurementSet, predicting
    and/or corrupting data on the given coordinates, or it can be used to
    create a fundamentally new MeasurementSet from descriptions of the
    array configuration and the observational parameters.  This
    is useful for making a simulator
    tool which will make a MeasurementSet from scratch.  In order to
    do this, you must also run {\tt setconfig}, {\tt setfield}, 
    {\tt setspwindow}, {\tt setfeed}, and {\tt settimes}.  Creating the
    actual MS is performed by {\tt observe}.  Data can be {\tt predict}-ed
    and then {\tt corrupted}-ed.  In this
    example, we read in the antenna coordinates from an ASCII file:
  </description>
  <input>
    
    <param type="string" name="ms">
      <description>MeasurementSet to be created</description>
      <value></value>
    </param>
  </input>
  <returns type="bool">Boolean</returns>
  <example>
    
    tabname = 'VLAC.LOCAL.TAB'
    asciifile = 'VLAC.LOCAL.STN'
    mytab=table.create()
    mytab.fromascii(tabname, asciifile);
    xx=[]; yy:=[]; zz:=[]; diam:=[];
    xx = mytab.getcol('X');  
    yy = mytab.getcol('Y');
    zz = mytab.getcol('Z');
    diam = mytab.getcol('DIAM');
    #
    sm.open('NEW1.ms')
    # do configuration
    posvla = me.observatory('vla');  #  me.observatory('ALMA') also works!
    sm.setconfig(telescopename='VLA', x=xx, y=yy, z=zz, dishdiameter=diam, 
	         mount='alt-az', antname='VLA',
                 coordsystem='local', referencelocation=posvla);

    # Initialize the spectral windows    
    sm.setspwindow(spwname='CBand', freq='5GHz',
		   deltafreq='50MHz',
		   freqresolution='50MHz',
		   nchannels=1,
		   stokes='RR RL LR LL');
    sm.setspwindow(spwname='LBand', freq='1.420GHz',
		   deltafreq='3.2MHz',
		   freqresolution='3.2MHz',
		   nchannels=32,
		   stokes='RR LL');
    
    # Initialize the source and calibrater
    sm.setfield(sourcename='My cal',
		sourcedirection=['J2000','00h0m0.0','+45.0.0.000'],
		calcode='A');
    sm.setfield(sourcename='My source',
		sourcedirection=['J2000','01h0m0.0','+47.0.0.000']);
  
    sm.setlimits(shadowlimit=0.001, elevationlimit='8.0deg');
    sm.setauto(autocorrwt=0.0);
    
    sm.settimes(integrationtime='10s', usehourangle=F, 
                referencetime=me.epoch('utc', 'today'));
    
    sm.observe('My cal', 'LBand', starttime='0s', stoptime='300s');
    sm.observe('My source', 'LBand', starttime='310s', stoptime='720s');
    sm.observe('My cal', 'CBand', starttime='720s', stoptime='1020s');
    sm.observe('My source', 'CBand', starttime='1030s', stoptime='1500s');
    
    sm.setdata(spwid=1, fieldid=1);
    sm.predict(imagename='M31.MOD');
    sm.setdata(spwid=2, fieldid=2);
    sm.predict(imagename='BigLBand.MOD');
    sm.close();
    
  </example>
</method>

 
<method type="function" name="openfromms">
  <shortdescription>Construct a simulator tool using an already existing  MS</shortdescription>
  
  <description>
    This is used to construct {\tt simulator} tools operating on
    an existing MS.  Data can be predicted and/or corrupted on the MS's given coordinates.
  </description>
  <input>
    
    <param type="string" name="ms">
      <description>MeasurementSet to be processed</description>
      <value></value>
      <choice>'MS'</choice>
    </param>
  </input>
  <returns type="bool"> Boolean</returns>
  <example>
    
    sm.openfromms('3C273XC1.MS');
    sm.predict('3C273XC1.imagename');
    sm.setnoise(simplenoise='10mJy');
    sm.setgain(interval='100s', amplitude=0.01);
    sm.corrupt();
    sm.close();
    
    
  </example>
</method>



 
<method type="function" name="close">
  <shortdescription>Close the newsimulator tool</shortdescription>
  
  <description>
    This is used to close {\tt newsimulator} tools. Note that the
    data is written to disk. This is a synonym for done.
  </description>
  <returns type="bool">Bool</returns>
</method>


<method type="function" name="done">
  <shortdescription>Close the newsimulator tool</shortdescription>
  
  <description>
    This is used to close and {\tt newsimulator} tools. Note that the
    data is written to disk. This is a synonym for close.
  </description>
  <returns type="bool">Bool</returns>
</method>


<method type="function" name="name">
  <shortdescription>Provide the name of the attached MeasurementSet</shortdescription>
  
  <description>
    Returns the name of the attached MeasurementSet.
  </description>
  <returns type="string">String</returns>
</method>


<method type="function" name="summary">
  <shortdescription>Summarize the current state</shortdescription>
  
  <description>
    Writes a summary of the properties of the simulator to the
    default logger.
  </description>
  <returns type="bool">Bool</returns>
</method>


<method type="function" name="type">
  <shortdescription>Return the type of this tool</shortdescription>
  
  <returns type="string">String or fail</returns>
  <description>
    This function returns the string `simulator'.  It is used so that  in
    a script, you can make sure this  variable is a simulator
    \tool.
  </description>
</method>



<method type="function" name="settimes">
  <shortdescription>Set integration time, {\em etc.}</shortdescription>
  
  <description> The start and stop times are referenced to
    {\tt referencetime}.  Use either starttime/stoptime or startha/stopha.
    If the hour angles are specified, then the start and stop times are
    calculated such that the start time is later than the reference time,
    but less than one day later.  The hour angles refer to the first
    source observed.
  </description>
  
  <input>    
    <param type="any" name="integrationtime">
      <description>Integration time</description>
      <any type="variant" /> 
      <value>10s</value>
    </param>
    
    <param type="bool" name="usehourangle">
      <description>Use starttime/stoptime as hour angles - else they are referenced to referencetime</description>
      <value>true</value>
    </param>
    
    <param type="any" name="referencetime">
      <description>Reference time for starttime and stoptime. Epoch Measure . E.g me.epoch('UTC', '50000.0d')
      </description>
      <any type="variant"/>
      <value>50000.0d</value>
      <choice>epoch measure</choice>
    </param>
  </input>
  <returns type='bool'>Bool</returns>
</method>


<method type="function" name="observe">
  <shortdescription>Observe a given configuration</shortdescription>
  
  <description>
    Observe a given source with a given spectral window for the specified
    times, including start, stop, integration, and gap times.  The start
    and stop times are referenced to {\tt referencetime}.  Use either
    starttime/stoptime or startha/stopha.  If the hour angles are
    specified, then the start and stop times are calculated such that the
    start time is later than the reference time, but less than one day
    later.  The hour angles refer to the first source observed.
  </description>
  <input>
    
    <param type="string" name="sourcename">
      <description>Name of source or field (must be specified)</description>
      <value></value>
      <choice>None</choice>
    </param>
    
    <param type="string" name="spwname">
      <description>Unique user-supplied name for this spectral window</description>
      <value></value>
      <choice>None</choice>
    </param>
    
    <param type="any" name="starttime">
      <description>Start time referenced to referenceepoch</description>
      <any type="variant" />
      <value>0s</value>
    </param>
    
    <param type="any" name="stoptime">
      <description>Stop time referenced to referenceepoch</description>
      <any type="variant" />
      <value>3600s</value>
    </param>

    <param type="bool" name="add_observation">
      <description>Add a new line to the OBSERVATION subtable for this
      call</description>
      <value type="bool">false</value>
    </param>

    <param type="bool" name="state_sig">
      <description>a new line will be added to STATE if the following don't match</description>
      <value type="bool">true</value>
    </param>
    
    <param type="bool" name="state_ref">
      <value type="bool">false</value>
    </param>
    
    <param type="double" name="state_cal">
      <value>0.0</value>
    </param>
    
    <param type="double" name="state_load">
      <value>0.0</value>
    </param>
    
    <param type="int" name="state_sub_scan">
      <value>0</value>
    </param>
    
    <param type="string" name="state_obs_mode">
      <value>OBSERVE\_TARGET.ON\_SOURCE</value>
    </param>

    <param type="string" name="observer">
      <value>CASA simulator</value>
    </param>

    <param type="string" name="project">
      <value>CASA simulation</value>
    </param>

  </input>
  <returns type='bool'>Bool</returns>
</method>


<method type="function" name="observemany">
  <shortdescription>Observe a given configuration</shortdescription>
  
  <description>
    Observe given sources with a given spectral window for the specified
    times, including start, stop, integration, and gap times.  The start
    and stop times are referenced to {\tt referencetime}.  Use either
    starttime/stoptime or startha/stopha.  If the hour angles are
    specified, then the start and stop times are calculated such that the
    start time is later than the reference time, but less than one day
    later.  The hour angles refer to the first source observed.
  </description>
  <input>
    
    <param type="stringArray" name="sourcenames">
      <description>Name of sources</description>
      <value></value>
      <choice>None</choice>
    </param>
    
    <param type="string" name="spwname">
      <description>Unique user-supplied name for this spectral window</description>
      <value></value>
      <choice>None</choice>
    </param>
    
    <param type="stringArray" name="starttimes">
      <description>Start times referenced to referenceepoch</description>
      <value>0s</value>
    </param>
    
    <param type="stringArray" name="stoptimes">
      <description>Stop time referenced to referenceepoch</description>
      <value>3600s</value>
    </param>
    
    <param type="stringArray" name="directions">
      <description></description>
      <value></value>
    </param>


    <param type="bool" name="add_observation">
      <description>Add a new line to the OBSERVATION subtable for this
      call</description>
      <value type="bool">false</value>
    </param>

    <param type="bool" name="state_sig">
      <description>a new line will be added to STATE if the following don't match</description>
      <value type="bool">true</value>
    </param>
    
    <param type="bool" name="state_ref">
      <value type="bool">false</value>
    </param>
    
    <param type="double" name="state_cal">
      <value>0.0</value>
    </param>
    
    <param type="double" name="state_load">
      <value>0.0</value>
    </param>
    
    <param type="int" name="state_sub_scan">
      <value>0</value>
    </param>
    
    <param type="string" name="state_obs_mode">
      <value>OBSERVE\_TARGET#ON\_SOURCE</value>
    </param>

    <param type="string" name="observer">
      <value>CASA simulator</value>
    </param>

    <param type="string" name="project">
      <value>CASA simulation</value>
    </param>

  </input>
  <returns type='bool'>Bool</returns>
</method>


<method type="function" name="setlimits">
  <shortdescription>Set limits for observing</shortdescription>
  
  <description>
    Data are flagged for two conditions:
    \begin{description}
    \item[Below elevation limit] If either of the antennas point below the
    specified elevation limit then the data are flagged. The elevation
    is calculated correctly for antennas at different locations (such as
    occurs in VLBI).
    \item[Shadowing] If one antenna shadows another such that the
    fractional (geometric) blockage is greater than the specified limit
    then the data are flagged. No correction for blockage is made for
    shadowed but non-flagged points.
    \end{description}
  </description>
  <input>
    
    <param type="double" name="shadowlimit">
      <description>Maximum fraction of geometrically shadowed area before flagging occurs</description>
      <value>1e-6</value>
      <choice>1e-6</choice>
    </param>
    
    <param type="any" name="elevationlimit">
      <description>Minimum elevation angle before flagging occurs</description>
      <any type="variant" />
      <value>10deg</value>
    </param>
  </input>
  <returns type='bool'>Bool</returns>
</method>


<method type="function" name="setauto">
  <shortdescription>Set autocorrelation weight</shortdescription>
  
  <description>
  </description>
  <input>
    
    <param type="double" name="autocorrwt">
      <description>Weight to assign autocorrelations (0=none)</description>
      <value>0.0</value>
      <choice>0.0</choice>
    </param>
  </input>
  <returns type='bool'>Bool</returns>
</method>


<method type="function" name="setconfig">
  <shortdescription>Set the antenna configuration</shortdescription>
  
  <description>
    Set the positions of the antennas.  Note that the name of the telescope will
    control which voltage pattern is applied to the data.
  </description>
  <input>
    
    <param type="string" name="telescopename">
      <description>Name of the telescope we are simulating (determines VP)</description>
      <value>VLA</value>
      <choice>'VLA'</choice>
    </param>
    
    <param type="doubleArray" name="x">
      <description>Vector of x values of all antennas [currently m]</description>
      <value>0</value>
      <choice>[]</choice>
    </param>
    
    <param type="doubleArray" name="y">
      <description>Vector of y values of all antennas [currently m]</description>
      <value>0</value>
      <choice>[]</choice>
    </param>
    
    <param type="doubleArray" name="z">
      <description>Vector of z values of all antennas [currently m]</description>
      <value>0</value>
      <choice>[]</choice>
    </param>
    
    <param type="doubleArray" name="dishdiameter">
      <description>Vector of diameters of all antennas [currently m]</description>
      <value>0</value>
      <choice>[]</choice>
    </param>
    
    <param type="doubleArray" name="offset">
      <description>Vector of offset of all antennas [currently m]</description>
      <value>0</value>
      <choice>[]</choice>
    </param>
    
    <param type="stringArray" name="mount">
      <description>Vector of mount types of all antennas (recognized mounts are 'ALT-AZ', 'EQUATORIAL', 'X-Y', 'ORBITING', 'BIZARRE'</description>
      <value>ALT-AZ</value>
      <choice>[]</choice>
    </param>
    
    <param type="stringArray" name="antname">
      <description>Vector of names of all antennas</description>
      <value>A</value>
      <choice>[]</choice>
    </param>
    
    <param type="stringArray" name="padname">
      <description>Vector of names of pads or stations</description>
      <value>P</value>
      <choice>[]</choice>
    </param>
    
    <param type="string" name="coordsystem">
      <description>Coordinate system of antenna positions [x,y,z], 
	possibilities are 'global', 'local' , 'longlat'</description>
      <value>global</value>
      <choice>'global'</choice>
    </param>
    
    <param type="any" name="referencelocation">
      <description>Reference location [required for local coords] Position Measure of Coordinates of array location. E.g me.position('ITRF', '30.5deg', -20.2deg', 6000km') or  me.observatory('ALMA')
      </description>
      <any type="variant"/>
      <value>ALMA</value>
      <choice>position measure</choice>
    </param>
  </input>
  <returns type='bool'>Bool</returns>
  <example>
    
    diam := [25, 25, 25, 25, 25]
    xx := [50, 100, 150, 200, 250]
    yy := [2, -5, -20, -50, -100]
    zz := [-0.5, -1.0, -1.5, -2.0, -2.5]
    posvla := dm.observatory('vla');
    sm.setconfig(telescopename='VLA', x=xx, y=yy, z=zz, dishdiameter=diam, 
                 mount='alt-az', antname='VLA',
                 coordsystem='local', referencelocation=posvla);
    
  </example>
  In this example we configure an array  of 5 dishes set at the VLA position. 
  We use the measures tool to give us the location of the vla.
</method>


<method type="function" name="setknownconfig">
  <shortdescription>Set the antenna configuration to a
    known array</shortdescription>
  
  <description>
    Sets the configuration to a known array such as VLAA, VLBA, EVN or
    ATCA6.0A. The arrays are those known to
    <link anchor="simhelper">simhelper</link>. All the information needed by
    setconfig is filled in.
  </description>
  <input>
    
    <param type="string" name="arrayname">
      <description>Name of the telescope configurationwe are simulating</description>
      <value>VLA</value>
      <choice>'VLA'</choice>
    </param>
  </input>
  <returns type='bool'>Bool</returns>
  <example>
    
    sm.setknownconfig('ATCA6.0A');
    
  </example>
</method>


<method type="function" name="setfeed">
  <shortdescription>Set the feed parameters</shortdescription>
  
  <description>
    The goal is to let the feed parameters be specified for each antenna and
    each spectral window.  At this moment, you only have the choice between
    'perfect R L' and 'perfect X Y' (i.e., you cannot invent your own
    corrupted feeds yet).  Doesn't need to be run if you want perfect R and
    L feeds.  
  </description>
  <input>
    
    <param type="string" name="mode">
      <description>Mode for specifying feed parameters (currently, perfect only)</description>
      <value></value>
    </param>
    <param type="doubleArray" name="x">
      <description> Some very secretive feed array parameter x</description>
      <value>0</value>
    </param>
    
    <param type="doubleArray" name="y">
      <description> Some more very secretive feed array parameter y
      </description>
      <value>0</value>
    </param>
    <param type="stringArray" name="pol">
      <description> Guess its the polarization of  feed arrays...
	your guess is as good as mine....if you know better let us know please !
      </description>
      <value>R</value>
      
    </param>
    
    
  </input>
  <returns type='bool'>Bool</returns>
</method>


<method type="function" name="setfield">
  <shortdescription>Set one or more observed fields</shortdescription>
  
  <description>
    Set one or more observed fields, including name, coordinates, calibration code.
    Can be invoked multiple times for a complex observation.
    Must be invoked at least once before {\tt observe}.
    
    If the distance to the object is set then the phase term includes a
    curvature for the near-field effect at the center of the image.
  </description>
  <input>
    
    <param type="string" name="sourcename">
      <description>Name of source or field (must be specified)</description>
      <value>SOURCE</value>
      <choice>'unknown'</choice>
    </param>
    
    <param type="any" name="sourcedirection">
      <description>Direction Measure of Coordinates of source to be observed. E.g me.direction('J2000', '30.5deg','-20.2deg').
      </description>
      <any type="variant" />
      <value></value>
    </param>
    
    <param type="string" name="calcode">
      <description>Calibration code</description>
      <value></value>
      <choice>'OBJ'</choice>
    </param>
    
    <param type="any" name="distance">
      <description>Distance to the object</description>
      <any type="variant" />
      <value>0m</value>
    </param>
  </input>
  <returns type='bool'>Bool</returns>
  <example>
    
    sm.setconfig(telescopename='VLA', x=xx, y=yy, z=zz, dishdiameter=diam, 
                 mount='alt-az', antname='VLA',
                 coordsystem='local', referencelocation=dm.observatory('vla'));

    sm.setspwindow(spwname='XBAND', freq='8GHz', deltafreq='50MHz',
                   freqresolution='50MHz', nchannels=1, stokes='RR
                   LL');
    dir0 = me.direction('B1950',  '16h00m0.0', '50d0m0.000')
    sm.setfield(sourcename='SIMU1', sourcedirection=dir0);
    sm.observe('SIMU1', 'XBAND', integrationtime='10s', usehourangle=T,
               starttime='0s', stoptime='3600s', 
    referencetime=reftime);
    
    
  </example>
</method>


<method type="function" name="setmosaicfield">
  <shortdescription>Set observed mosaic fields</shortdescription>
  
  <description>
    Set mosaic fields by internally invoking {\tt setfield} multiple times.
    Currently only handle a rectangular mosaicing pattern.
    Either setfield or setmosaicfield must be invoked at least once before {\tt observe}.
    
    If the distance to the object is set then the phase term includes a
    curvature for the near-field effect at the center of the image.
  </description>
  <input>
    
    <param type="string" name="sourcename">
      <description>Name of source or field (must be specified).</description>
      <value>SOURCE</value>
      <choice>'unknown'</choice>
    </param>
    
    <param type="string" name="calcode">
      <description>Calibration code</description>
      <value></value>
      <choice>''</choice>
    </param>
    
    <param type="any" name="fieldcenter">
      <description>Coordinates of mosaic field center</description>
      <any type="variant"/>
      <value></value>
      <choice>MDirection</choice>
    </param>
    
    <param type="int" name="xmosp">
      <description>Number of mosaic pointing in horizontal direction</description>
      <value>1</value>
    </param>
    
    <param type="int" name="ymosp">
      <description>Number of mosaic pointing in vertical direction</description>
      <value>1</value>
    </param>
    
    <param type="any" name="mosspacing">
      <description>Spacing between mosaic pointings</description>
      <any type="variant" />
      <value>1arcsec</value>
    </param>
    
    <param type="any" name="distance">
      <description>Distance to the object</description>
      <any type="variant" />
      <value>0m</value>
    </param>
  </input>
  <returns type='bool'>Bool</returns>
  <example>
    
    sm.setconfig(telescopename='VLA', x=xx, y=yy, z=zz, dishdiameter=diam,
                 mount='alt-az', antname='VLA',
                 coordsystem='local', referencelocation=dm.observatory('vla'));
                                                                                
    sm.setspwindow(spwname='XBAND', freq='8GHz', deltafreq='50MHz',
                   freqresolution='50MHz', nchannels=1, stokes='RR
                   LL');
    dir0 = me.direction('B1950',  '16h00m0.0', '50d0m0.000')
    sm.setmosaicfield(sourcename='SIMU1', fieldcenter=dir0,
                      xmosp=2, ymosp=2, mosspacing='154.5arcsec');
    sm.settimes(integrationtime='10s');
    sm.observe('SIMU1_1', 'XBAND', starttime='0s', stoptime='100s');
    sm.observe('SIMU1_2', 'XBAND', starttime='110s', stoptime='210s');
    sm.observe('SIMU1_3', 'XBAND', starttime='220s', stoptime='320s');
    sm.observe('SIMU1_4', 'XBAND', starttime='330s', stoptime='430s');
    
    
  </example>
  In this example, a 2x2 mosaic pattern is set centered around the direction 
  specified (dir0). The setmosaicfield name each mosaic field with i
  sourcename+'\_i', where i= 1..4.
</method>

 
<method type="function" name="setspwindow">
   <shortdescription>Set one or more spectral windows</shortdescription>
   
<description>
Set one or more spectral windows for the observations, including starting
frequency, number of channels, channel increment and resolution, and stokes
parameters observed.  Can be invoked multiple times for a complex observation.
Must be invoked at least once before {\tt observe}.
</description>
<input>

     <param type="string" name="spwname">
     <description>Unique user-supplied name for this spectral window</description>
     <value>XBAND</value>
     <choice>'XBAND'</choice>
     </param>

     <param type="any" name="freq" >
     <description>Starting frequency</description>
     <any type="variant" />
     <value>8.0e9Hz</value>
     </param>

     <param type="any" name="deltafreq" >
     <description>Frequency increment per channel</description>
     <any type="variant" />
     <value>50e6Hz</value>
     </param>

     <param type="any" name="freqresolution" >
     <description>Frequency resolution per channel</description>
     <any type="variant" />
     <value>50.e6Hz</value>
     </param>

     <param type="string" name="refcode" >
     <description>Spectral reference code e.g. LSRK, TOPO, BARY</description>
     <value type="string">TOPO</value>
     <allowed kind="enum">
       <value type="string">LSRK</value>
       <value type="string">LSRD</value>
       <value type="string">BARY</value>
       <value type="string">GEO</value>
       <value type="string">TOPO</value>
       <value type="string">GALACTO</value>
       <value type="string">LGROUP</value>
       <value type="string">CMB</value>
     </allowed>
     </param>

     <param type="int" name="nchannels">
     <description>Number of channels</description>
     <value>1</value>
     </param>

     <param type="string" name="stokes">
     <description>Stokes types to simulate</description>
     <value>RR LL</value>
     <choice>'RR LL'</choice>
     </param>
</input>
<returns type='bool'>Bool</returns>
<example>

To simulate a two spectral window (or two IF's in VLA jargon) data
set, use setpwid as follows (here we are simulating 16 channels, 50MHz
wide channel for each spectral window)


sm.setspwindow(spwname='CBAND', freq='2GHz', deltafreq='50MHz',
                   freqresolution='50MHz', nchannels=16, stokes='RR LL');

sm.setspwindow(spwname='SBAND', freq='5GHz', deltafreq='50MHz',
                   freqresolution='50MHz', nchannels=16, stokes='RR LL');



Note that the spwname is used in {\tt observe} to determine which spectral window
is used.

</example>
</method>

 
   <method type="function" name="setdata">
   <shortdescription>Set the data parameters selection for subsequent processing</shortdescription>
   
<description>
This setup tool function selects which data are to be used
subsequently. After invocation of setdata, only the selected data are
operated on. 

</description>
<input>

     <param type="intArray" name="spwid">
     <description>Spectral Window Ids (0 relative) to select</description>
     <value>0</value>
     </param>

     <param type="intArray" name="fieldid">
     <description>Field Ids (0 relative) to select</description>
     <value>0</value>
     </param>

     <param type="string" name="msselect">
     <description>TQL select string applied as a logical "and" with the other selections</description>
     <value></value>
     <choice>String</choice>
     </param>


</input>
<returns type='bool'>Bool</returns>
</method>



 
   <method type="function" name="predict">
   <shortdescription>Predict astronomical data from an image</shortdescription>
   
<description>
Predict astronomical data from an image.  The (u,v) coordinates already
exist, either from a MeasurementSet we have read in or by generating the
MeasurementSet coordinates and empty data through {\tt create()}.  We
simply predict onto these coordinates.
</description>
<input>

     <param type="stringArray" name="imagename">
     <description>Name of image from which to predict visibilities</description>
     <value></value>
     </param>

     <param type="string" name="complist">
     <description>Name of component list</description>
     <value></value>
     <choice>String</choice>
     </param>

     <param type="bool" name="incremental">
     <description>Add this model to the existing Data Visibilities?</description>
     <value>false</value>
     </param>
</input>
<returns type='bool'>Bool</returns>
</method>

 
   <method type="function" name="setoptions">
   <shortdescription>Set various processing options</shortdescription>
   
<description>

For most of these, set the options for {\tt predict} details.  See also {\tt imager} help
for more details.

To simulate single dish data, use gridft=SD and gridfunction=PB.

</description>
<input>

     <param type="string" name="ftmachine">
     <description>Fourier transform machine. Possibilities are 'ft', 
     'sd'</description>
     <value>ft</value>
     <choice>'ft'</choice>
     </param>

     <param type="int" name="cache">
     <description>Size of gridding cache in complex pixels</description>
     <value>0</value>
     </param>

     <param type="int" name="tile">
     <description>Size of a gridding tile in pixels (in 1 dimension)</description>
     <value>16</value>
     </param>

     <param type="string" name="gridfunction">
     <description>Gridding function. String: 'SF'|'BOX'|'PB' </description>
     <value>SF</value>
     <choice>'SF'</choice>
     </param>

     <param type="any" name="location">
     <description>Location used in phase rotations. Position Measure of Coordinates of array location. E.g me.position('ITRF', '30.5deg', '-20.2deg', '6000km') or  me.observatory('ALMA')
     </description>
     <any type="variant"/>
     <value>ALMA</value>
     <choice>position measure</choice>
     </param>

     <param type="double" name="padding">
     <description>Padding factor in image plane (\&gt;=1.0)</description>
     <value>1.3</value>
     </param>

     <param type="int" name="facets">
     <description>Number of facets</description>
     <value>1</value>
     </param>

     <param type="double" name="maxdata">
     <description>Maximum data to write to a single TSM file (MB)</description>
     <value>2000.0</value>
     </param>

     <param type="int" name="wprojplanes">
     <description>Number of projection planes when using wproject as the ft-machine </description>
     <value>1</value>
     </param>

</input>
<returns type="bool">Bool</returns>
<example>

sm.setoptions(cache=10000000, tile=32, gridfunction='BOX', me.location('vla'))

</example>

</method>

 
   <method type="function" name="setvp">
   <shortdescription>Set the voltage pattern model for subsequent processing</shortdescription>
   
<description>
Set the voltage pattern model (and hence, the primary beam) used for a Telecope.
There are currently two ways to set the voltage pattern: by using the extensive
list of defaults which the system knows about, or by creating a voltage pattern
description with the <link anchor="imager:vpmanager">vpmanager</link>.  The default voltage patterns
include both a high and a low frequency VP for the WSRT, a VP for each observing
band at the AT, several VP's for the VLA, including the approrpiate beam squint for
each observing band, and  Gaussian for the BIMA dishes.
If you are simulating a telescope which doesn't yet exist, you will need to supply
a model voltage pattern using the <link anchor="imager:vpmanager">vpmanager</link>.
</description>
<input>

     <param type="bool" name="dovp">
     <description>Multiply by the voltage pattern (ie, primary beam) when simulating </description>
     <value>true</value>
     </param>

     <param type="bool" name="usedefaultvp">
     <description>Look up the default VP for this telescope and frequency?</description>
     <value>true</value>
     </param>

     <param type="string" name="vptable">
     <description>If usedefaultvp is false, provide a VP Table made with vpmanager</description>
     <value></value>
     <choice>Table</choice>
     </param>

     <param type="bool" name="dosquint">
     <description>Activate the beam squint in the VP model</description>
     <value>true</value>
     </param>

     <param type="any" name="parangleinc" >
     <description>Parallactice angle increment for squint application</description>
     <any type="variant" />
     <value>360deg</value>
     </param>

     <param type="any" name="skyposthreshold" >
     <description> Position threshold on the sky for feed arrays ??
     </description>
     <any type="variant" />
     <value>180deg</value>
     </param>
     <param type="double" name="pblimit">
     <description> Primary beam limit to use in feed arrays ?
     </description>
     <value>1.0e-2</value>
     </param>

</input>
<returns type="bool">Bool</returns>
<example>

sm.setvp(dovp=T, usedefaultvp=F, vptable='MyAlternateVLAPBModel.TAB', dosquint=F);

</example>
</method>



 
   <method type="function" name="corrupt">
   <shortdescription>Corrupt the data with visibility errors</shortdescription>
   
<description>
Add errors specified by the {\tt set} functions (such as noise, 
gains, polarization leakage, bandpass, etc) to the visibility data.
The errors are applied to the MODEL\_DATA, and written to the
DATA and CORRECTED\_DATA columns.   Note that {\tt corrupt} handles
only visibility-plane effects, not image-plane effects such as
pointing errors and voltage patterns, which get applied in {\tt predict}.
Note, the function applies errors to both cross- and auto-correlation
data; The auto-correlation data are corrupted properly only for
the thermalnoise set by {\tt setnoise}.


</description>

<returns type="bool">Boolean</returns>
<example>

sm,openfromms('3C273XC1.MS');
sm.predict('3C273XC1.FAKE.IMAGE');
sm.setnoise( mode='simplenoise', simplenoise='0.1Jy');
sm.setpa( mode='calculate');
sm.corrupt();

</example>
</method>

 
   <method type="function" name="reset">
   <shortdescription>Reset the corruption terms</shortdescription>
   
<description>
Reset the visibility corruption terms: this means that {\tt corrupt}
introduces no errors.
</description>
<returns type="bool">Bool</returns>
</method>

 
   <method type="function" name="setbandpass">
   <shortdescription>Set the bandpasses</shortdescription>
   
<description>
Set the level of bandpass errors. The error distributions are normal, mean
zero, with the variances as specified. (Not yet implemented).
</description>
<input>

     <param type="string" name="mode">
     <description>Mode of operation. String: 'calculate'|'table'</description>
     <value>calculate</value>
     <choice>'calculate'</choice>
     </param>

     <param type="string" name="table">
     <description>Name of table</description>
     <value></value>
     <choice>''</choice>
     </param>

     <param type="any" name="interval" >
     <description>Coherence interval e.g. '1h'</description>
     <any type="variant" />
     <value>3600s</value>
     </param>

     <param type="doubleArray" name="amplitude">
     <description>Variances errors in amplitude and phase</description>
     <value>0.0</value>
     </param>
</input>
<returns type='bool'>Bool</returns>
</method>

 
   <method type="function" name="setapply">
   <shortdescription>Arrange for corruption by existing cal tables</shortdescription>
   
<description>
Arrange for corruption by existing cal tables, in a manner exactly analogous to
calibrater.setapply. 
</description>
<input>

     <param type="string" direction="in" name="table">
     <description>Calibration table name</description>
     <value></value>
     </param>

     <param type="string" direction="in" name="type">
     <description>Component type</description>
     <value>B</value>
     <value>BPOLY</value>
     <value>G</value>
     <value>GSPLINE</value>
     <value>D</value>
     <value>P</value>
     <value>T</value>
     <value>TOPAC</value>
     <value>GAINCURVE</value>
     <value></value>
     </param>

     <param type="double" direction="in" name="t">
     <description>Interpolation interval (seconds)</description>
     <value>0.0</value>
     </param>

     <param type="any" direction="in" name="field">
     <description>Select on field</description>
     <any type="variant"/>
     <value></value>
     </param>

     <param type="string" direction="in" name="interp">
     <description>Interpolation type (in time)</description>
     <value>aipslin</value>
     <value>nearest</value>
     <value>linear</value>
     </param>

     <param type="bool" direction="in" name="calwt">
     <description>Calibrate weights?</description>
     <value>false</value>
     </param>

     <param type="intArray" direction="in" name="spwmap">
     <description>Spectral windows to apply</description>
     <value>-1</value>
     </param>

     <param type="double" direction="in" name="opacity">
     <description>Array-wide zenith opacity (for type='TOPAC')</description>
     <value>0.0</value>
     </param>

</input>
<returns type='bool'>Bool</returns>
</method>

   <method type="function" name="setgain">
   <shortdescription>Set the gains</shortdescription>
   
<description>
Set the level of gain errors.  Gain drift is implemented as fractional brownian
motion with rms amplitude as specified.  Interval is not currently used, 
but future statistical models for gain errors (e.g. simple Gaussian) will use it.
<!--
The error distributions are normal, mean zero, with the variances as specified.
-->
</description>
<input>

     <param type="string" name="mode">
     <description>Mode of operation. String: 'fbm'</description>
     <value>fbm</value>
     <choice>'fbm'</choice>
     </param>

     <param type="string" name="table">
     <description>Optional name of table to write</description>
     <value></value>
     <choice>''</choice>
     </param>

     <param type="any" name="interval" >
     <description>timescale for gain variations NOT USED</description>
     <any type="variant" />
     <value>10s</value>
     </param>

     <param type="doubleArray" name="amplitude">
     <description>amplitude scale (RMS) for gain variations [real,imag] or scalar</description>
     <value>0.01</value>
     <choice>[]</choice>
     </param>

</input>
<returns type='bool'>Bool</returns>
</method>


   <method type="function" name="settrop">
   <shortdescription>Set tropospheric gain corruptions</shortdescription>
   
<description>
Set the atmosphere. 
</description>
<input>

     <param type="string" name="mode">
     <description>Mode of operation - screen or individual antennas</description>
     <value>screen</value>
     <choice>'screen'</choice>
     </param>

     <param type="string" name="table">
     <description>Name of cal table</description>
     <value></value>
     <choice>''</choice>
     </param>

     <param type="double" name="pwv">
     <description>total precipitable water vapour in mm</description>
     <value>3.0</value>
     </param>

     <param type="double" name="deltapwv">
     <description>RMS PWV fluctuations *as a fraction of PWV parameter*</description>
     <value>0.15</value>
     </param>

     <param type="double" name="beta">
     <description>exponent of fractional brownian motion</description>
     <value>1.1</value>
     </param>

     <param type="double" name="windspeed">
     <description>wind speed for screen type corruption (m/s)</description>
     <value>7.</value>
     </param>

</input>
<returns type='bool'>Bool</returns>
</method>




<method type="function" name="setpointingerror">
   <shortdescription>Set the Pointing error</shortdescription>
   
<description>
Set the pointing error from a calpointing table
</description>
<input>

     <param type="string" name="epjtablename">
     <description>Name of a table that has E-Jones errors for Pointing
     </description>
     <value></value>
     </param>

     <param type="bool" name="applypointingoffsets">
     <description>Apply pointing offsets</description>
     <value>false</value>
     </param>

     <param type="bool" name="dopbcorrection">
     <description>apply primary beam correction</description>
     <value>false</value>
     </param>

</input>
<returns type='bool'>Bool</returns>
</method>

 
   <method type="function" name="setleakage">
   <shortdescription>Set the polarization leakage</shortdescription>
   
<description>
Set the level of polarization leakage between feeds.
Currently, no time dependence is available.
</description>
<input>

     <param type="string" name="mode">
     <description>Mode of operation. String: 'constant'</description>
     <value>constant</value>
     <choice>'constant'</choice>
     </param>

     <param type="string" name="table">
     <description>Optional name of table to write</description>
     <value></value>
     <choice>''</choice>
     </param>

<!--
     <param type="any" name="interval" >
     <description>Coherence interval e.g. '5.0h'</description>
     <any type="variant" />
     <value>18000s</value>
     </param>
-->

     <param type="doubleArray" name="amplitude">
     <description>Magnitude of pol leakage [real,imag]</description>
     <value>0.01</value>
     <choice>[]</choice>
     </param>

     <param type="doubleArray" name="offset">
     <description>Meam of pol leakage [real,imag]</description>
     <value>0.</value>
     <choice>[]</choice>
     </param>
</input>
<returns type='bool'>Bool</returns>
</method>

 
   <method type="function" name="oldsetnoise">
   <shortdescription>Set the noise level fixed sigma (mode=simplenoise) or
   Brown's equation (mode=calculate) OBSOLETE VERSION</shortdescription>
   
<description>
Set various system parameters from which the thermal (ie, random additive) noise level 
will be calculated.  

For mode=simplenoise, one specifies the standard deviation for the noise to be
added to real and imaginary parts of the visibility.

For mode=calculate, the noise will vary with dish diameter, antenna efficiency,
system temperature, opacity, sky temperature, etc.  The noise will increase with
the airmass if {\tt tau} is greater than zero.  The noise is calculated according to
the {\it Brown Equation} (ie, R.L. Brown's calculation of MMA sensitivity, 3Oct95):
\begin{equation}
\Delta S = \frac{ 4 \sqrt{2} [ T_{rx}e^{\tau A} + T_{atm} ( e^{\tau A} - \epsilon_{l}) + T_{cmb}] }
                {  \epsilon_{q} \epsilon_{a} \pi D^2 \sqrt{\Delta \nu \Delta t }}
\end{equation}
</description>
<input>

     <param type="string" name="mode">
     <description>Mode of operation. String: 'simplenoise'|'calculate' 
     </description>
     <value>calculate</value>
     <choice>'simplenoise'</choice>
     <choice>'calculate'</choice>
     </param>

     <param type="string" name="table">
     <description>Name of noise table - not currently implemented</description>
     <value></value>
     <choice>''</choice>
     </param>

     <param type="any" name="simplenoise" >
     <description>Level of noise (if mode=simplenoise)</description>
     <any type="variant" />
     <value>0.0Jy</value>
     </param>

     <param type="double" name="antefficiency">
     <description>antenna efficiency</description>
     <value>0.8</value>
     <choice>0.8</choice>
     </param>

     <param type="double" name="correfficiency">
     <description>Correlation efficiency</description>
     <value>0.85</value>
     <choice>0.85</choice>
     </param>

     <param type="double" name="spillefficiency">
     <description>Forward spillover efficiency</description>
     <value>0.85</value>
     <choice>0.85</choice>
     </param>

     <param type="double" name="tau">
     <description>Atmospheric Opacity</description>
     <value>0.1</value>
     <choice>0.1</choice>
     </param>

     <param type="double" name="trx">
     <description>Receiver temp (ie, all non-atmospheric Tsys contributions) [K]</description>
     <value>50</value>
     <choice>50</choice>
     </param>

     <param type="double" name="tatmos">
     <description>(Physical, not Brightness) Temperature of atmosphere [K]</description>
     <value>230.0</value>
     <choice>230.0</choice>
     </param>

     <param type="double" name="tcmb">
     <description>Temperature of cosmic microwave background [K]</description>
     <value>2.7</value>
     <choice>2.7</choice>
     </param>
</input>
<returns type='bool'>Bool</returns>
</method>


 

   <method type="function" name="setnoise">
   <shortdescription>Set the noise level fixed sigma (mode=simplenoise) or
   Brown's equation using the ATM model for frequency-dependent atmospheric
   opacity (mode=tsys-atm) or Brown's equation, manually specifying the zenith
   opacity (constant across the band) and atmospheric temperature 
   (mode=tsys-manual)</shortdescription>

<description>
Set various system parameters from which the thermal (ie, random additive) noise level 
will be calculated.  

For mode=simplenoise, one specifies the standard deviation for the noise to be
added to real and imaginary parts of the visibility.

For mode=tsys-atm or tsys-atm, the noise will vary with dish diameter, antenna efficiency,
system temperature, opacity, sky temperature, etc.  The noise will increase with
the airmass if tau is greater than zero.  The noise is calculated according to
the Brown Equation (ie, R.L. Brown's calculation of MMA sensitivity, 3Oct95):
dS = 4 sqrt(2) [ T\_rx e\^{tau A} + T\_atm ( e\^{tau A} - epsilon\_l) + T\_cmb] / 
               [ epsilon\_q epsilon\_a pi D\^2 sqrt{Delta nu Delta t} ]

For mode=tsys-atm, the sky brightness temperature is calculated using an atmospheric model created for the user-input PWV.
For mode=tsys-manual, the user specifies the sky brightness temperature 
manually.
</description>
   
<input>

     <param type="string" name="mode">
     <description>Mode of operation.</description>
     <value>simplenoise</value>
     <choice>'simplenoise'</choice>
     <choice>'tsys-atm'</choice>
     <choice>'tsys-manual'</choice>
     </param>

     <param type="string" name="table">
     <description>Name of optional cal table to write</description>
     <value></value>
     <choice>''</choice>
     </param>

     <param type="any" name="simplenoise" >
     <description>Level of noise if not calculated</description>
     <any type="variant" />
     <value>0.1Jy</value>
     </param>



     <param type="any" name="pground" >
     <description>Ground pressure for ATM model (if tsys-atm)</description>
     <any type="variant" />
     <value>560mbar</value>
     </param>

     <param type="double" name="relhum">
     <description>ground relative humidity for ATM model (if tsys-atm)</description>
     <value>20.0</value>
     </param>

     <param type="any" name="altitude" >
     <description>site altitude for ATM model (if tsys-atm)</description>
     <any type="variant" />
     <value>5000m</value>
     </param>

     <param type="any" name="waterheight" >
     <description>Height of water layer for ATM model (if tsys-atm)</description>
     <any type="variant" />
     <value>200m</value>
     </param>

     <param type="any" name="pwv" >
     <description>Precipitable Water Vapor ATM model (if tsys-atm)</description>
     <any type="variant" />
     <value>1mm</value>
     </param>


     <param type="double" name="tatmos">
     <description>Temperature of atmosphere [K] (if tsys-manual)</description>
     <value>250.0</value>
     </param>

     <param type="double" name="tau">
     <description>Zenith Atmospheric Opacity (if tsys-manual)</description>
     <value>0.1</value>
     </param>



     <param type="double" name="antefficiency">
     <description>Antenna efficiency</description>
     <value>0.8</value>
     </param>

     <param type="double" name="spillefficiency">
     <description>Forward spillover efficiency</description>
     <value>0.85</value>
     </param>

     <param type="double" name="correfficiency">
     <description>Correlation efficiency</description>
     <value>0.88</value>
     </param>

     <param type="double" name="trx">
     <description>Receiver temp (ie, all non-atmospheric Tsys contributions) [K]</description>
     <value>50</value>
     </param>

     <param type="double" name="tground">
     <description>Temperature of ground/spill [K]</description>
     <value>270.0</value>
     </param>

     <param type="double" name="tcmb">
     <description>Temperature of cosmic microwave background [K]</description>
     <value>2.73</value>
     </param>

     <param type="bool" name="OTF">
     <description>calculate noise on-the-fly (WARNING: only experts with high-RAM machines should use False)</description>
     <value type="bool">true</value>
     </param>

     <param type="double" name="senscoeff">
     <description>sensitivity constant (1./sqrt(2) for interferometer [default]; 1. for total power)</description>
     <value>0.</value>
     </param>

     <param type="int" name="rxtype">
       <description>Receiver type; 0=2SB, 1=DSB e.g. ALMA B9</description>
       <value>0</value>
     </param>

</input>
<returns type='bool'>Bool</returns>
</method>



   <method type="function" name="setpa">
   <shortdescription>Corrupt phase by the parallactic angle</shortdescription>
   
<description>
Corrupt phase by the parallactic angle
</description>
<input>

     <param type="string" name="mode">
     <description>Mode of operation. String: 'calculate'|'table'</description>
     <value>calculate</value>
     <choice>'calculate'</choice>
     </param>

     <param type="string" name="table">
     <description>Name of table</description>
     <value></value>
     <choice>''</choice>
     </param>

     <param type="any" name="interval" >
     <description>Interval for parallactic angle application, e.g. '10s'</description>
     <any type="variant" />
     <value>10s</value>
     </param>
</input>
<returns type='bool'>Bool</returns>
</method>

 
   <method type="function" name="setseed">
   <shortdescription>Set the seed for the random number generator</shortdescription>
   
<description>

</description>
<input>

     <param type="int" name="seed">
     <description>Seed</description>
     <value>185349251</value>
     <choice>185349251</choice>
     </param>
</input>
<returns type='bool'>Bool</returns>
</method>

</tool>


</casaxml>
