<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" ?>
<casaxml xmlns="http://casa.nrao.edu/schema/psetTypes.html"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://casa.nrao.edu/schema/casa.xsd
file:///opt/casa/code/xmlcasa/xml/casa.xsd">


<task type="function" name="tclean" category="imaging" visibility="experimental">

  <shortdescription>Construct and deconvolve images</shortdescription>

  <description>Form images from visibilities. Handles continuum and spectral line cubes.</description>

  <input>

<!--============================================== -->
<!--                            Data Selection Parameters                                            -->
<!--============================================== -->

    <param type="any" name="vis" kind="ms" mustexist="true">
   <shortdescription>Name of input visibility file(s)</shortdescription>
<description>Name(s) of input visibility file(s)
               default: none; 
               example: vis='ngc5921.ms'
                        vis=['ngc5921a.ms','ngc5921b.ms']; multiple MSes
</description>
      <any type="variant" limittypes="string stringArray"/>
      <value type="string"></value>
    </param>


    <param type="bool" name="selectdata" visibility="hidden">
     <shortdescription>Enable data selection parameters</shortdescription>
<description>Enable data selection parameters in the task interface.
</description>
      <value type="bool">True</value>
    </param>

    <param type="any" name="field" subparam="true">
     <shortdescription>field(s) to select</shortdescription>
<description> Select fields to image or mosaic.  Use field id(s) or name(s).
                  ['go listobs' to obtain the list id's or names]
               default: ''= all fields
                 If field string is a non-negative integer, it is assumed to
                 be a field index otherwise, it is assumed to be a 
		 field name
                 field='0~2'; field ids 0,1,2
                 field='0,4,5~7'; field ids 0,4,5,6,7
                 field='3C286,3C295'; field named 3C286 and 3C295
                 field = '3,4C*'; field id 3, all names starting with 4C
                 For multiple MS input, a list of field strings can be used:
                 field = ['0~2','0~4']; field ids 0-2 for the first MS and 0-4
                         for the second 
                 field = '0~2'; field ids 0-2 for all input MSes

</description>
      <any type="variant" limittypes="string stringArray"/>
      <value type="string"></value>
    </param>

    <param type="any" name="spw" subparam="true">
     <shortdescription>spw(s)/channels to select</shortdescription>
<description> Select spectral window/channels
               NOTE: channels de-selected here will contain all zeros if
                         selected by the parameter mode subparameters.    
               default: ''=all spectral windows and channels
                 spw='0~2,4'; spectral windows 0,1,2,4 (all channels)
                 spw='0:5~61'; spw 0, channels 5 to 61
                 spw='&lt;2';   spectral windows less than 2 (i.e. 0,1)
                 spw='0,10,3:3~45'; spw 0,10 all channels, spw 3, 
				    channels 3 to 45.
                 spw='0~2:2~6'; spw 0,1,2 with channels 2 through 6 in each.
                 For multiple MS input, a list of spw strings can be used:
                 spw=['0','0~3']; spw ids 0 for the first MS and 0-3 for the second
                 spw='0~3' spw ids 0-3 for all input MS
                 spw='3:10~20;50~60' for multiple channel ranges within spw id 3
                 spw='3:10~20;50~60,4:0~30' for different channel ranges for spw ids 3 and 4
                 spw='0:0~10,1:20~30,2:1;2;3'; spw 0, channels 0-10,
                      spw 1, channels 20-30, and spw 2, channels, 1,2 and 3
                 spw='1~4;6:15~48' for channels 15 through 48 for spw ids 1,2,3,4 and 6

</description>
      <any type="variant" limittypes="string stringArray"/>
      <value type="string"></value>
    </param>

    <param type="any" name="timerange" subparam="true">
     <shortdescription>Range of time to select from data</shortdescription>
<description>Range of time to select from data

                   default: '' (all); examples,
                   timerange = 'YYYY/MM/DD/hh:mm:ss~YYYY/MM/DD/hh:mm:ss'
                   Note: if YYYY/MM/DD is missing date defaults to first 
			 day in data set
                   timerange='09:14:0~09:54:0' picks 40 min on first day
                   timerange='25:00:00~27:30:00' picks 1 hr to 3 hr 
			     30min on NEXT day
                   timerange='09:44:00' pick data within one integration 
		             of time
                   timerange='&gt; 10:24:00' data after this time
                   For multiple MS input, a list of timerange strings can be
                   used:
                   timerange=['09:14:0~09:54:0','&gt; 10:24:00']
                   timerange='09:14:0~09:54:0''; apply the same timerange for
                                                 all input MSes 

</description>
      <any type="variant" limittypes="string stringArray"/>
      <value type="string"></value>
    </param>

    <param type="any" name="uvrange" subparam="true">
     <shortdescription>Select data within uvrange</shortdescription>
<description>Select data within uvrange (default unit is meters)
                   default: '' (all); example:
                   uvrange='0~1000klambda'; uvrange from 0-1000 kilo-lambda
                   uvrange='&gt; 4klambda';uvranges greater than 4 kilo lambda
                   For multiple MS input, a list of uvrange strings can be
                   used:
                   uvrange=['0~1000klambda','100~1000klamda']
                   uvrange='0~1000klambda'; apply 0-1000 kilo-lambda for all
                                            input MSes
 </description>
      <any type="variant" limittypes="string stringArray"/>
      <value type="string"></value>
    </param>

    <param type="any" name="antenna" subparam="true">
     <shortdescription>Select data based on antenna/baseline</shortdescription>
<description>Select data based on antenna/baseline

                   default: '' (all)
                   If antenna string is a non-negative integer, it is 
 		   assumed to be an antenna index, otherwise, it is
 		   considered an antenna name.
                   antenna='5\&amp;6'; baseline between antenna index 5 and 
 				 index 6.
                   antenna='VA05\&amp;VA06'; baseline between VLA antenna 5 
 				       and 6.
                   antenna='5\&amp;6;7\&amp;8'; baselines 5-6 and 7-8
                   antenna='5'; all baselines with antenna index 5
                   antenna='05'; all baselines with antenna number 05 
 				(VLA old name)
                   antenna='5,6,9'; all baselines with antennas 5,6,9 
 				   index number
                   For multiple MS input, a list of antenna strings can be
                   used:
                   antenna=['5','5\&amp;6'];
                   antenna='5'; antenna index 5 for all input MSes

</description>
      <any type="variant" limittypes="string stringArray"/>
      <value type="string"></value>
    </param>

    <param type="any" name="scan" subparam="true">
     <shortdescription>Scan number range</shortdescription>
<description>Scan number range

                   default: '' (all)
                   example: scan='1~5'
                   For multiple MS input, a list of scan strings can be used:
                   scan=['0~100','10~200']
                   scan='0~100; scan ids 0-100 for all input MSes
                   Check 'go listobs' to insure the scan numbers are in order.

</description>
      <any type="variant" limittypes="string stringArray"/>
      <value type="string"></value>
    </param>
    
    <param type="any" name="observation" subparam="true">
     <shortdescription>Observation ID range</shortdescription>
<description>Observation ID range
                   default: '' (all)
                   example: observation='1~5'
</description>
      <any type="variant" limittypes="string int"/>
      <value type="string"></value>
    </param>

    <param type="any" name="intent" subparam="true">
     <shortdescription>Scan Intent(s)</shortdescription>
<description>Scan Intent(s)

                   default: '' (all)
                   example: intent='TARGET_SOURCE'  
                   example: intent='TARGET_SOURCE1,TARGET_SOURCE2'  
                   example: intent='TARGET_POINTING*'
</description>
      <any type="variant" limittypes="string stringArray"/>
      <value type="string"></value>
    </param>

    <param type="string" name="datacolumn" subparam="true">
     <shortdescription>Data column to image(data,corrected)</shortdescription>
<description>Data column to image (data or observed, corrected)
                     default:'corrected'
                     ( If 'corrected' does not exist, it will use 'data' instead )
                     
</description>
      <value type="string">corrected</value>
    </param>


<!--============================================== -->
<!--                            Image Definition Parameters                                         -->
<!--============================================== -->

    <param type="any" name="imagename" required="true">
     <shortdescription>Pre-name of output images</shortdescription>
<description>Pre-name of output images
                     
                       example : imagename='try'

                       Output images will be (a subset of) :

                       try.psf              - Point spread function
                       try.residual      - Residual image
                       try.image         - Restored image
                       try.model         - Model image (contains only flux components)
                       try.sumwt        - Single pixel image containing sum-of-weights.
                                                 (for natural weighting, sensitivity=1/sqrt(sumwt))

                       Widefield projection algorithms (gridder=mosaic,awproject) will
                       compute the following images too.
                       try.weight        - FT of gridded weights or the 
                                                  un-normalized sum of PB-square (for all pointings)
                       try.pb               -  PB = sqrt(weight) normalized to a maximum of 1.0

                       For multi-term wideband imaging, all relevant images above will 
                       have additional .tt0,.tt1, etc suffixes to indicate Taylor terms,
                       plus the following extra output images.
                       try.alpha            - spectral index
                       try.alpha.error   - estimate of error on spectral index
                       try.beta              - spectral curvature (if nterms \> 2)
                      

                       Tip : Include a directory name in 'imagename' for all 
                               output images to be sent there instead of the
                               current working directory : imagename='mydir/try'

                       Tip : Restarting an imaging run without changing 'imagename' 
                               implies continuation from the existing model image on disk.
                                - If 'startmodel' was initially specified it needs to be set to "" 
                                  for the restart run (or tclean will exit with an error message).
                                - By default, the residual image and psf will be recomputed
                                  but if no changes were made to relevant parameters between 
                                  the runs, set calcres=False, calcpsf=False to resume directly from
                                  the minor cycle without the (unnecessary) first major cycle.
                                To automatically change 'imagename' with a numerical 
                                increment, set overwrite=False (see inline docs for 'overwrite').

</description>
      <any type="variant" limittypes="int string stringArray"/>
      <value type="string"></value>
    </param>

    <param type="any" name="imsize" > <!-- subparam="true"> -->
     <shortdescription>Number of pixels</shortdescription>
<description>Number of pixels</description>
      <any type="variant" limittypes="int intArray"/>
      <value type="intArray">100</value>
    </param>

    <param type="any" name="cell" > <!-- subparam="true"> -->
     <shortdescription>Cell size</shortdescription>
<description>Cell size</description>
      <any type="variant" limittypes="int double intArray doubleArray string stringArray"/>
      <value type="stringArray">"1arcsec"</value>
    </param>

    <param type="any" name="phasecenter" > <!-- subparam="true"> -->
     <shortdescription>>Phase center of the image</shortdescription>
<description>Phase center of the image</description>
      <any type="variant" limittypes="int string"/>
      <value type="string"></value>
    </param>

    <param type="string" name="stokes" > <!-- subparam="true"> -->
     <shortdescription>Stokes Planes to make</shortdescription>
<description>Stokes Planes to make</description>
      <value type="string">I</value>
    </param>

    <param type="string" name="projection" > <!-- subparam="true"> -->
     <shortdescription>Coordinate projection (SIN, HPX)</shortdescription>
<description>Coordinate projection (SIN, HPX) </description>
      <value type="string">SIN</value>
    </param>

    <param type="string" name="startmodel" > <!-- subparam="true"> -->
     <shortdescription>Name of starting model image</shortdescription>
<description>Name of starting model image </description>
      <value type="string"></value>
    </param>

<!--============================================== -->

<!--============================================== -->
<!--                            Spectral Parameters                                                     -->
<!--============================================== -->

    <param type="any" name="specmode" required="true">
     <shortdescription>Spectral definition mode (mfs,cube,cubedata(,cubesrc))</shortdescription>
<description>Spectral definition mode (mfs,cube,cubedata)</description>
      <value type="string">mfs</value>
    </param>

    <param type="any" name="reffreq" subparam="true">
     <shortdescription>Reference frequency</shortdescription>
<description>Reference frequency</description>
      <value type="string"></value>
    </param>

    <param type="int" name="nchan" subparam="true">
     <shortdescription>Number of channels in the output image</shortdescription>
<description>Number of channels in the output image</description>
      <value type="int">-1</value>
    </param>

    <param type="any" name="start" subparam="true">
     <shortdescription>First channel (e.g. start=3,start=\'1.1GHz\',start=\'15343km/s\')</shortdescription>
<description>First channel (e.g. start=3,start=\'1.1GHz\',start=\'15343km/s\')</description>
      <value type="string"></value>
    </param>

    <param type="any" name="width" subparam="true">
     <shortdescription>Channel width (e.g. width=2,width=\'0.1MHz\',width=\'10km/s\')</shortdescription>
<description>Channel width (e.g. width=2,width=\'0.1MHz\',width=\'10km/s\')</description>
      <value type="string"></value>
    </param>

    <param type="string" name="outframe" subparam="true">
     <shortdescription>Spectral reference frame in which to interpret \'start\' and \'width\'</shortdescription>
<description>Spectral reference frame in which to interpret \'start\' and \'width\'</description>
      <value type="string">LSRK</value>
    </param>

    <param type="string" name="veltype" subparam="true">
     <shortdescription>Velocity type (radio, z, ratio, beta, gamma, optical)</shortdescription>
<description>Velocity type (radio, z, ratio, beta, gamma, optical)</description>
      <value type="string">radio</value>
    </param>

    <param type="any" name="restfreq" subparam="true">
     <shortdescription>List of rest frequencies</shortdescription>
<description>List of rest frequencies</description>
      <value type="stringArray"></value>
    </param>

    <param type="any" name="sysvel" subparam="true">
     <shortdescription>Systemic velocity (for mode=cubesrc)</shortdescription>
<description>Systemic velocity (for mode=cubesrc) </description>
      <value type="string"></value>
    </param>

    <param type="string" name="sysvelframe" subparam="true">
     <shortdescription>Spectral frame in which sysvel is specified (for mode=cubesrc only)</shortdescription>
<description>Spectral frame in which sysvel is specified (for mode=cubesrc only)</description>
      <value type="string"></value>
    </param>

    <param type="string" name="interpolation" subparam="true">
     <shortdescription>Spectral interpolation (nearest,linear,cubic)</shortdescription>
<description>Spectral interpolation (nearest,linear,cubic)</description>
      <value type="string">linear</value>
	    <allowed kind="enum">
	      <value>nearest</value>
              <value>linear</value>
	      <value>cubic</value>
	    </allowed>
    </param>


<!--============================================== -->
<!--                            Imaging/Gridding Parameters                                                      -->
<!--============================================== -->

    <param type="string" name="gridder">
           <shortdescription>Gridding options (standard, wproject, widefield, mosaic, imagemosaic, awproject)</shortdescription>
<description>Gridding options (standard, wproject, widefield, mosaic, imagemosaic, awproject)

                       The following options choose different gridding convolution
                       functions for the process of convolutional resampling of the measured
                       visibilities onto a regular uv-grid prior to an inverse FFT. 
                       Model prediction (degridding) also uses these same functions.
                       Several wide-field effects can be accounted for via careful choices of 
                       convolution functions. Gridding (degridding) runtime will rise in 
                       proportion to the support size of these convolution functions (in uv-pixels).

                       standard,
                       ft,
                       gridft : Prolate Spheroid with 3x3 uv pixel support size (ref)

                       wproject,
                       wprojectft : W-Projection algorithm to correct for the widefield
                                           non-coplanar baseline effect.

                                           wprojplanes is the number of distinct w-values at 
                                           which to compute and use different gridding convolution
                                           functions (see help for wprojplanes). 
                                          Convolution function support size can range
                                           from 5x5 to few 100 x few 100. 

                       widefield : Facetted imaging with or without W-Projection per facet.

                                        A set of facets x facets subregions of the specified image
                                        are gridded separately using their respective phase centers 
                                        (to minimize max W). Deconvolution is done on the joint
                                        full size image, using a PSF from the first subregion.

                                        wprojplanes=1 : standard prolate spheroid gridder per facet.
                                        wprojplanes &gt; 1 : W-Projection gridder per facet.
                                        nfacets=1, wprojplanes &gt; 1 : Pure W-Projection and no facetting
                                        nfacets=1, wprojplanes=1 : Same as standard,ft,gridft

                                        A combination of facetting and W-Projection is relevant only for
                                        very large fields of view.

                       mosaic,
                       ftmosaic,
                       mosaicft : A-Projection with azimuthally symmetric beams without
                                        sidelobes, beam rotation or squint correction. 
                                        Gridding convolution functions per visibility are computed
                                        from FTs of PB models per antenna.
                                        This gridder can be run on single fields as well as mosaics.

                                       VLA : PB polynomial fit model (Napier and Rots, 1982)
                                       ALMA : Airy disks for a 10.7m dish (for 12m dishes) and
                                                   6.25m dish (for 7m dishes) each with 0.75m 
                                                   blockages (Hunter/Brogan 2011)
                                       
                                       Typical gridding convolution function support sizes are 
                                       between 7 and 50 depending on the desired
                                       accuracy (given by the uv cell size or image field of view).

                       awproject,
                       awprojectft : A-Projection with azimuthally asymmetric beams and 
                                            including beam rotation, squint correction,
                                            conjugate frequency beams and W-projection.
                                            Gridding convolution functions are computed from 
                                            aperture illumination models per antenna and optionally
                                            combined with W-Projection kernels as well.
                                            This gridder can be run on single fields as well as mosaics.
 
                                        VLA : Uses ray traced model (VLA and EVLA) including feed 
                                                 leg and subreflector shadows, off-axis feed location 
                                                 (for beam squint and other polarization effects), and
                                                 a Gaussian fit for the feed beams (Ref: Brisken 2009)
                                        ALMA : Similar ray-traced model as above (but the correctness
                                                    of its polarization properties remains un-verified).

                                       Typical gridding convolution function support sizes are 
                                       between 7 and 50 depending on the desired
                                       accuracy (given by the uv cell size or image field of view). 
                                       When combined with W-Projection they can be significantly larger.

                       imagemosaic : Grid and iFT each pointing separately and combine the
                                                images as a linear mosaic (weighted by a PB model) in 
                                               the image domain before a joint minor cycle. 

                                               VLA/ALMA PB models are same as for gridder='mosaicft'


                       Notes on PB models : 

                       (1) Several different sources of PB models are used in the modes 
                            listed above. This is partly for reasons of algorithmic flexibility 
                            and partly due to the current  lack of a common beam model 
                            repository or consensus on what beam models are most appropriate.

                       (2) For ALMA and gridder='mosaicft', ray-traced (TICRA) beams 
                            are also available via the vpmanager tool. 
                            For example, call the following before the tclean run.
                           vp.setpbimage(telescope="ALMA", 
                           compleximage='/home/casa/data/trunk/alma/responses/ALMA_0_DV__0_0_360_0_45_90_348.5_373_373_GHz_ticra2007_VP.im', 
                           antnames=['DV'+'%02d'%k for k in range(25)]) 
                           ( Currently this will work only for non-parallel runs )

</description>
	    <value type="string">standard</value>
	    <allowed kind="enum">
	      <value>standard</value>
	      <value>ft</value>
	      <value>gridft</value>
              <value>widefield</value>
              <value>wproject</value>
              <value>wprojectft</value>
	      <value>mosaic</value>
	      <value>ftmosaic</value>
	      <value>mosaicft</value>
	      <value>imagemosaic</value>
	      <value>awproject</value>
	      <value>awprojectft</value>
	    </allowed>
    </param>

    <param type="int" name="facets" subparam="true">
     <shortdescription>Number of facets on a side</shortdescription>
<description>Number of facets on a side

                       A set of (facets x facets) subregions of the specified image
                       are gridded separately using their respective phase centers 
                       (to minimize max W). Deconvolution is done on the joint
                       full size image, using a PSF from the first subregion/facet.

</description>
      <value type="int">1</value>
    </param>

    <param type="int" name="wprojplanes" subparam="true">
     <shortdescription>Number of distinct w-values for convolution functions</shortdescription>
<description>Number of distinct w-values at which to compute and use different
                       gridding convolution functions for W-Projection

                       An appropriate value of wprojplanes depends on the presence/absence 
                       of a bright source far from the phase center, the desired dynamic 
                       range of an image in the presence of a bright far out source,  
                       the maximum w-value in the measurements, and the desired trade off
                       between accuracy and computing cost.

                       As a (rough) guide, VLA L-Band D-config may require a
                       value of 128 for a source 30arcmin away from the phase 
                       center. A-config may require 1024 or more. To converge to an
                       appropriate value, try starting with 128 and then increasing
                       it if artifacts persist. W-term artifacts (for the VLA) typically look
                       like arc-shaped smears in a synthesis image or a shift in source 
                       position between images made at different times. These artifacts
                       are more pronounced the further the source is from the phase center.

                       There is no harm in simply always choosing a large value (say, 1024) 
                       but there will be a significant performance cost to doing so, especially
                       for gridder='awproject' where it is combined with A-Projection.

</description>
      <value type="int">1</value>
    </param>

    <param type="bool" name="aterm" subparam="true">
           <shortdescription>Use aperture illumination function during gridding</shortdescription>
<description>Use aperture illumination function during gridding</description>
	    <value type="bool">True</value>
    </param>

    <param type="bool" name="psterm" subparam="true">
           <shortdescription>Use prolate spheroidal during gridding</shortdescription>
<description>Use prolate spheroidal during gridding</description>
	    <value type="bool">False</value>
    </param>

    <param type="bool" name="wbawp" subparam="true">
           <shortdescription>Use wideband A-terms</shortdescription>
<description>Use wideband A-terms</description>
	    <value type="bool">True</value>
    </param>

    <param type="bool" name="conjbeams" subparam="true">
           <shortdescription>Use conjugate frequency for wideband A-terms</shortdescription>
<description>Use conjugate frequency for wideband A-terms </description>
	    <value type="bool">True</value>
    </param>

    <param type="string" name="cfcache" subparam="true">
           <shortdescription>>Convolution function cache directory name</shortdescription>
<description>Convolution function cache directory name</description>
	    <value type="string"></value>
    </param>

    <param type="double" name="computepastep" subparam="true">
     <shortdescription>At what parallactic angle interval to recompute AIFs (deg)</shortdescription>
<description>At what parallactic angle interval to recompute AIFs (deg) </description>
      <value type="double">360.0</value>
    </param>

    <param type="double" name="rotatepastep" subparam="true">
     <shortdescription>At what parallactic angle interval to rotate nearest AIF (deg) </shortdescription>
<description>At what parallactic angle interval to rotate nearest AIF (deg) </description>
      <value type="double">360.0</value>
    </param>

    <param type="double" name="pblimit" subparam="true">
     <shortdescription>>PB gain level at which to cut off image calculations </shortdescription>
<description>PB gain level at which to cut off image calculations  </description>
      <value type="double">0.2</value>
    </param>

    <param type="string" name="normtype" subparam="true">
     <shortdescription>Normalization type (flatnoise, flatsky)</shortdescription>
<description>Normalization type (flatnoise, flatsky) </description>
      <value type="string">flatnoise</value>
    </param>


<!--============================================== -->
<!--                            Deconvolution Parameters                                            -->
<!--============================================== -->


    <param type="string" name="deconvolver">
      <shortdescription>Minor cycle algorithm (hogbom,clark,multiscale,mtmfs,mem,clarkstokes)</shortdescription>
<description>Name of minor cycle algorithm (hogbom,clark,multiscale,mtmfs,mem,clarkstokes)
                       
                       Each of the following algorithms operate on residual images and psfs 
                       from the gridder and produce output model and restored images.
                       Minor cycles stop and a major cycle is triggered when cyclethreshold 
                       or cycleniter are reached. For all methods, components are picked from
                       the entire extent of the image or (if specified) within a mask.

                       hogbom : An adapted version of Hogbom Clean (ref)
                                       - Find the location of the peak residual
                                       - Add this delta function component to the model image
                                       - Subtract a scaled and shifted PSF of the same size as the image
                                         from regions of the residual image where the two overlap.
                                       - Repeat

                       clark : An adapted version of Clark Clean (ref)
                                       - Find the location of max(I^2+Q^2+U^2+V^2) 
                                       - Add delta functions to each stokes plane of the model image
                                       - Subtract a scaled and shifted PSF within a small patch size
                                         from regions of the residual image where the two overlap.
                                       - After several iterations trigger a Clark major cycle to subtract
                                         components from the visibility domain, but without de-gridding.
                                       - Repeat

                       clarkstokes : Clark Clean operating separately per Stokes plane

                       multiscale : MultiScale Clean (ref)
                                       - Smooth the residual image to multiple scale sizes
                                       - Find the location and scale at which the peak occurs
                                       - Add this multiscale component to the model image
                                       - Subtract a scaled,smoothed,shifted PSF (within a small
                                         patch size per scale) from all residual images
                                       - Repeat from step 2

                       mtmfs : Multi-term (Multi Scale) Multi-Frequency Synthesis (ref)
                                       - Smooth each Taylor residual image to multiple scale sizes
                                       - Solve a NTxNT system of equations per scale size to compute
                                         Taylor coefficients for components at all locations
                                       - Compute gradient chi-square and pick the Taylor coefficients
                                          and scale size at the location with maximum reduction in chi-square
                                       - Add multi-scale components to each Taylor-coefficient model image
                                       - Subtract scaled,smoothed,shifted PSF (within a small patch size
                                         per scale) from all smoothed Taylor residual images
                                       - Repeat from step 2

                       mem : Maximum Entropy Method (ref)
                                       - Iteratively solve for values at all individual pixels via the
                                         MEM method. It minimizes an objective function of
                                         chi-square plus entropy (here, a measure of difference 
                                         between the current model and a flat prior model).

                                         (Note : This MEM implementation is not very robust. 
                                                      Improvements will be made in the future.)


</description>
	    <value type="string">hogbom</value>
	    <allowed kind="enum">
	      <value>hogbom</value>
              <value>clark</value>
	      <value>clarkstokes</value>
              <value>clark2</value>
	      <value>clarkstokes2</value>
	      <value>multiscale</value>
	      <value>mtmfs</value>
	      <value>mem</value>
<!--	      <value>aasp</value> -->
	    </allowed>
    </param>

    <param type="any" name="scales" subparam="true">
           <shortdescription>List of scale sizes (in pixels) for multi-scale algorithms</shortdescription>
	   <description>List of scale sizes (in pixels) for multi-scale and mtmfs algorithms.
                                  --&gt;  scales=[0,6,20] 
                                  This set of scale sizes should represent the sizes 
                                  (diameters in units of number of pixels) 
                                  of dominant features in the image being reconstructed.
                                  
                                  The smallest scale size is recommended to be 0 (point source),
                                  the second the size of the synthesized beam and the third 3-5
                                  times the synthesized beam, etc. For example, if the synthesized 
                                  beam is 10" FWHM and cell=2",try scales = [0,5,15].
               
                                  For numerical stability, the largest scale must be
                                  smaller than the image (or mask) size and smaller than or
                                  comparable to the scale corresponding to the lowest measured 
                                  spatial frequency (as a scale size much larger than what the 
                                  instrument is sensitive to is unconstrained by the data making
                                  it harder to recovery from errors during the minor cycle).
	   </description>
	    <any type="variant" limittypes="intArray floatArray"/>
	    <value type="intArray"></value>
    </param>

    <param type="int" name="nterms" subparam="true">
     <shortdescription>Number of Taylor coefficients in the spectral model</shortdescription>
<description>Number of Taylor coefficients in the spectral model

                       - nterms=1 : Assume flat spectrum source
                       - nterms=2 : Spectrum is a straight line with a slope
                       - nterms &gt; 2 : A polynomial of order n-1

                       From a Taylor expansion of the expression of a power law, the 
                       spectral index is derived as alpha = taylorcoeff_1 / taylorcoeff_0
                       
                       Spectral curvature is similarly derived when possible.

                       The optimal number of Taylor terms depends on the available 
                       signal to noise ratio, bandwidth ratio, and spectral shape of the 
                       source as seen by the telescope (sky spectrum x PB spectrum).

                       nterms=2 is a good starting point for wideband EVLA imaging 
                       if there is at least one bright source for which a dynamic range of
                       greater than few 100 is desired.

                       Spectral artifacts for the VLA often look like spokes radiating out from
                       a bright source (i.e. in the image made with standard mfs imaging).
                       If increasing the number of terms does not eliminate these artifacts,
                       check the data for inadequate bandpass calibration. If the source is away 
                       from the pointing center, consider including wide-field corrections too.

</description>
      <value type="int">2</value>
    </param>

    <param type="any" name="restoringbeam" subparam="true">
           <shortdescription>Restoring beam shape to use. Default is the PSF main lobe</shortdescription>
<description> Restoring beam shape/size to use.
 
                       - restoringbeam='' or ['']
                         A Guassian fitted to the PSF main lobe (separately per image plane). 
                          
                       - restoringbeam='10.0arcsec'
                         Use a circular Gaussian of this width for all planes

                       - restoringbeam=['8.0arcsec','10.0arcsec','45deg']
                         Use this elliptical Gaussisn for all planes

                       - restoringbeam='common'
                         Automatically estimate a common beam shape/size appropriate for
                         all planes. PSF main lobes from all planes are examined,
                         bad or outlier beams identified based on their area and axial ratio, 
                         and the largest beam from the remaining 'good' planes is
                         picked as the common beam. 

</description>
	    <any type="variant" limittypes="string stringArray"/>
	    <value type="stringArray"></value>
    </param>

<!--
    <param type="any" name="specthreshold" subparam="true">
     <shortdescription>xxx</shortdescription>
<description>Intensity threshold above which spectral index is computed</description>
      <value type="string">'0.0Jy'</value>
    </param>
-->

<!--============================================== -->
<!--                            Outlier Parameters  (files with any of the above)               -->
<!--============================================== -->
    <param type="string" name="outlierfile">
     <shortdescription>Name of outlier-field image definitions</shortdescription>
<description>Name of outlier-field image definitions</description>
      <value type="string"></value>
    </param>


<!--============================================== -->
<!--                            Weighting Parameters                                            -->
<!--============================================== -->

    <param type="string" name="weighting">
           <shortdescription>Weighting scheme (natural,uniform,briggs)</shortdescription>
<description>Weighting scheme (natural,uniform,briggs)</description>
	    <value type="string">natural</value>
    </param>

    <param type="double" name="robust" subparam="true">
           <shortdescription>Robustness parameter</shortdescription>
<description>Robustness parameter</description>
	    <value type="double">0.5</value>
    </param>

    <param type="int" name="npixels" subparam="true">
           <shortdescription>Number of pixels to determine uv-cell size (0 : -/+ 3 pixels)</shortdescription>
<description>Number of pixels to determine uv-cell size (0 : -/+ 3 pixels)</description>
	    <value type="int">0</value>
    </param>

<!--
    <param type="bool" name="uvtaper">
           <shortdescription>xxx</shortdescription>
<description>Apply additional uv tapering of visibilities</description>
	    <value type="bool">False</value>
    </param>
-->

    <param type="stringArray" name="uvtaper" subparam="true">
	   <shortdescription>uv-taper on outer baselines in uv-plane</shortdescription>
<description>uv-taper on outer baselines in uv-plane

                   [bmaj, bmin, bpa] taper Gaussian scale in uv or 
 		   angular units. NOTE: the on-sky FWHM in arcsec is roughly
                   the uv taper/200 (klambda).
                   default: outertaper=[]; no outer taper applied
 		   example: outertaper=['5klambda']  circular taper 
 				FWHM=5 kilo-lambda
                            outertaper=['5klambda','3klambda','45.0deg']
                            outertaper=['10arcsec'] on-sky FWHM 10 arcseconds
                            outertaper=['300.0'] default units are lambda 
 			        in aperture plane

</description>
	    <value type="vector">
	      <value></value>
	    </value>
    </param>

<!--
    <param type="stringArray" name="innertaper" subparam="true">
	   <shortdescription>xxx</shortdescription>
<description>uv-taper in center of uv-plane (not implemented)</description>
	    <value>1.0</value>
    </param>
-->


<!--============================================== -->
<!--                            Iteration Control Parameters                                         -->
<!--============================================== -->


    <param type="int" name="niter">
     <shortdescription>Maximum number of iterations</shortdescription>
<description>Maximum number of iterations
  
  Iterations are counted across all channels...

  Major Cycle Triggers
    - cyclethreshold
    - cycleniter

  
</description>
      <value type="int">0</value>
    </param>

    <param type="double" name="gain" subparam="true">
     <shortdescription>Loop gain</shortdescription>
<description>Loop gain</description>
      <value type="double">0.1</value>
    </param>

    <param type="any" name="threshold" subparam="true">
     <shortdescription>Stopping threshold (number, in units of Jy)</shortdescription>
<description>Stopping threshold (number, in units of Jy)</description>
      <value type="double">0.0</value>
    </param>

    <param type="int" name="cycleniter" subparam="true">
     <shortdescription>Maximum number of minor-cycle iterations before triggering a major cycle</shortdescription>
<description>Maximum number of minor-cycle iterations (per plane) before triggering a major cycle</description>
      <value type="int">-1</value>
    </param>

    <param type="double" name="cyclefactor" subparam="true">
     <shortdescription>Scaling on PSF sidelobe level to compute the minor-cycle stopping threshold.</shortdescription>
<description>Scaling on PSF sidelobe level to compute the minor-cycle stopping threshold.</description>
      <value type="double">1.0</value>
    </param>

    <param type="double" name="minpsffraction" subparam="true">
     <shortdescription>PSF fraction that marks the max depth of cleaning in the minor cycle</shortdescription>
<description>PSF fraction that marks the max depth of cleaning in the minor cycle </description>
      <value type="double">0.05</value>
    </param>

    <param type="double" name="maxpsffraction" subparam="true">
     <shortdescription>>PSF fraction that marks the minimum depth of cleaning in the minor cycle </shortdescription>
<description>PSF fraction that marks the minimum depth of cleaning in the minor cycle </description>
      <value type="double">0.8</value>
    </param>

<!--    <param type="bool" name="interactive" subparam="true">
	   <shortdescription>xxx</shortdescription>
<description>True to be able to modify masks and parameters at runtime</description>
	    <value type="bool">False</value>
    </param> -->
    <param type="any" name="interactive" subparam="true">
     <shortdescription>True to be able to modify masks and parameters at runtime</shortdescription>
<description>True to be able to modify masks and parameters at runtime</description>
      <any type="variant" limittypes="bool int"/>
      <value type="bool">False</value>
    </param>

    <param type="string" name="mask" subparam="true">
	   <shortdescription>Mask string (image name or region file or region string)</shortdescription>
<description>Mask string (image name or region file or region string)</description>
	    <value type="string"></value>
    </param>


<!--============================================== -->
<!--                            Other Operational Parameters                                       -->
<!--============================================== -->

    <param type="bool" name="overwrite">
     <shortdescription>True : Re-use existing images. False : Increment imagename</shortdescription>
<description>True : Re-use existing images. False : Increment imagename</description>
      <value type="bool">True</value>
    </param>


    <param type="string" name="savemodel"> 
	   <shortdescription>Options to save model at the end (none, virtual, modelcolumn)</shortdescription>
<description>Options to save model at the end (none, virtual, modelcolumn)
                      ...some info on when to use what....and relative runtime
</description>
	    <value type="string">none</value>
<!--	    <allowed kind="enum">
	      <value>none</value>
              <value>virtual</value>
	      <value>modelcolumn</value>
	    </allowed> -->
    </param>

    <param type="bool" name="calcres">
	   <shortdescription>Calculate residual image</shortdescription>
<description>Calculate residual image</description>
	    <value type="bool">True</value>
    </param>

    <param type="bool" name="calcpsf">
	   <shortdescription>Calculate PSF</shortdescription>
<description>Calculate PSF</description>
	    <value type="bool">True</value>
    </param>

    <param type="bool" name="parallel">
	   <shortdescription>Run major cycles in parallel</shortdescription>
<description>Run major cycles in parallel
                       
                       Parallel tclean will run only if casapy has already been started using mpirun.
                       Please refer to HPC documentation for details on how to start this on your system.
                       
                       Example :  mpirun -n 3 -xterm 0 `which casapy`

                       Continuum Imaging :
                          -  Data are partitioned (in time) into NProc pieces
                          -  Gridding/iFT is done separately per partition
                          -  Images (and weights) are gathered and then normalized
                          - One non-parallel minor cycle is run
                          - Model image is scattered to all processes
                          - Major cycle is done in parallel per partition

                      Cube Imaging :
                          - Data and Image coordinates are partitioned (in freq) into NProc pieces
                          - Each partition is processed independently (major and minor cycles)
                          - All processes are synchronized at major cycle boundaries for convergence checks
                          - At the end, cubes from all partitions are concatenated along the spectral axis

                      Note 1 :  Iteration control for cube imaging is independent per partition. 
                                    - There is currently no communication between them to synchronize
                                       information such as peak residual and cyclethreshold. Therefore, 
                                       different chunks may trigger major cycles at different levels.
                                    - For cube imaging in parallel, there is currently no interactive masking.
                                   (Proper synchronization of iteration control is work in progress.)

                      Note 2 :  Use savemodel='none' with parallel runs.
                                     If you need to save model visibilities for a future uvsub or self-calibration
                                     please run a separate niter=0 run with parallel=False.
                                     (Proper parallel writing of the model is work in progress).

</description>
	    <value type="bool">False</value>
    </param>



<!--    <param type="string" name="clusterdef" subparam="true">
           <shortdescription>xxx</shortdescription>
<description>Name of a file that contains the cluster definition</description>
	    <value type="string"></value>
    </param>
-->
<!--
    <param type="string" name="workdir" subparam="true">
           <shortdescription>xxx</shortdescription>
<description>Directory name for per-node products (default=imagename.workdir)</description>
	    <value type="string"></value>
    </param>
-->

<!--=============================================== -->
<!--===============  Constraints                        ============== -->

   <constraints>

<!--
     <when param="vis">
      <notequals type="string" value=""> 
	 <default param="field"><value>""</value></default>
	 <default param="spw"><value>""</value></default>
	 <default param="timerange"><value>""</value></default>
	 <default param="uvrange"><value>""</value></default>
	 <default param="antenna"><value>""</value></default>
	 <default param="scan"><value>""</value></default>
	 <default param="observation"><value>""</value></default>
	 <default param="intent"><value>""</value></default>
	 <default param="datacolumn"><value>"corrected"</value></default>
       </notequals>
      </when> 
-->

     <when param="selectdata">
      <equals type="bool" value="True"> 
	 <default param="field"><value>""</value></default>
	 <default param="spw"><value>""</value></default>
	 <default param="timerange"><value>""</value></default>
	 <default param="uvrange"><value>""</value></default>
	 <default param="antenna"><value>""</value></default>
	 <default param="scan"><value>""</value></default>
	 <default param="observation"><value>""</value></default>
	 <default param="intent"><value>""</value></default>
	 <default param="datacolumn"><value>"corrected"</value></default>
       </equals>
      </when> 

<!--
     <when param="imagename">
       <notequals type="string" value=""> 
	 <default param="imsize"><value>100</value></default>
	 <default param="cell"><value>"1arcsec"</value></default>
	 <default param="phasecenter"><value>""</value></default>
	 <default param="stokes"><value>"I"</value></default>
	 <default param="projection"><value>"SIN"</value></default>
	 <default param="startmodel"><value>""</value></default>
       </notequals>
      </when> 
-->
     <when param="specmode">
       <equals type="string" value="mfs">
	 <default param="reffreq"><value>""</value></default>
<!--	 <default param="nterms"><value>1</value></default> -->
       </equals>
       <equals type="string" value="cube">
	 <default param="nchan"><value>-1</value></default>
	 <default param="start"><value>""</value></default>
	 <default param="width"><value>""</value></default>
	 <default param="outframe"><value>""</value></default>
	 <default param="veltype"><value>"radio"</value></default>
	 <default param="restfreq"><value>[]</value></default>
	 <default param="interpolation"><value>"linear"</value></default>
       </equals>
       <equals type="string" value="cubesrc">
	 <default param="nchan"><value>-1</value></default>
	 <default param="start"><value>""</value></default>
	 <default param="width"><value>""</value></default>
	 <default param="outframe"><value>""</value></default>
	 <default param="veltype"><value>"radio"</value></default>
	 <default param="restfreq"><value>[]</value></default>
	 <default param="sysvel"><value>""</value></default>
	 <default param="sysvelframe"><value>""</value></default>
	 <default param="interpolation"><value>"linear"</value></default>
       </equals>
       <equals type="string" value="cubedata">
	 <default param="nchan"><value>-1</value></default>
	 <default param="start"><value>""</value></default>
	 <default param="width"><value>""</value></default>
	 <default param="veltype"><value>"radio"</value></default>
	 <default param="restfreq"><value>[]</value></default>
	 <default param="interpolation"><value>"linear"</value></default>
       </equals>
     </when>

     <when param="gridder">
       <equals type="string" value="standard">
       </equals>
       <equals type="string" value="widefield">
	 <default param="wprojplanes"><value>1</value></default>
	 <default param="facets"><value>1</value></default>
       </equals>
       <equals type="string" value="wproject">
	 <default param="wprojplanes"><value>1</value></default>
       </equals>
       <equals type="string" value="wprojectft">
	 <default param="wprojplanes"><value>1</value></default>
       </equals>
       <equals type="string" value="mosaic">
	 <default param="pblimit"><value>0.01</value></default>
	 <default param="normtype"><value>"flatnoise"</value></default>
       </equals>
       <equals type="string" value="mosaicft">
	 <default param="pblimit"><value>0.01</value></default>
	 <default param="normtype"><value>"flatnoise"</value></default>
       </equals>
       <equals type="string" value="ftmosaic">
	 <default param="pblimit"><value>0.01</value></default>
	 <default param="normtype"><value>"flatnoise"</value></default>
       </equals>
       <equals type="string" value="imagemosaic">
	 <default param="wprojplanes"><value>1</value></default>
	 <default param="pblimit"><value>0.01</value></default>
	 <default param="normtype"><value>"flatnoise"</value></default>
       </equals>
       <equals type="string" value="awproject">
	 <default param="wprojplanes"><value>1</value></default>
	 <default param="pblimit"><value>0.01</value></default>
	 <default param="normtype"><value>"flatnoise"</value></default>
	 <default param="psterm"><value>False</value></default>
	 <default param="cfcache"><value>""</value></default>
	 <default param="computepastep"><value>360.0</value></default>
	 <default param="rotatepastep"><value>360.0</value></default>
	 <default param="wbawp"><value>False</value></default>
	 <default param="conjbeams"><value>False</value></default>
       </equals>
       <equals type="string" value="awprojectft">
	 <default param="wprojplanes"><value>1</value></default>
	 <default param="pblimit"><value>0.01</value></default>
	 <default param="normtype"><value>"flatnoise"</value></default>
	 <default param="psterm"><value>False</value></default>
	 <default param="cfcache"><value>""</value></default>
	 <default param="computepastep"><value>360.0</value></default>
	 <default param="rotatepastep"><value>360.0</value></default>
	 <default param="wbawp"><value>False</value></default>
	 <default param="conjbeams"><value>False</value></default>
       </equals>
     </when>

     <when param="weighting">
       <equals type="string" value="natural">
	 <default param="uvtaper"><value>[]</value></default>
       </equals>
       <equals type="string" value="uniform">
       </equals>
       <equals type="string" value="briggs">
	 <default param="robust"><value>0.5</value></default>
	 <default param="npixels"><value>0</value></default>
	 <default param="uvtaper"><value>[]</value></default>
       </equals>
     </when>

<!--
     <when param="uvtaper">
       <equals type="bool" value="False">
       </equals>
       <equals type="bool" value="True">
	 <default param="outertaper"><value>[]</value></default>
	 <default param="innertaper"><value>[]</value></default>
       </equals>
     </when>
-->

     <when param="deconvolver">
       <equals type="string" value="hogbom">
	 <default param="restoringbeam"><value type="stringArray"></value></default>
       </equals>
       <equals type="string" value="clark">
	 <default param="restoringbeam"><value type="stringArray"></value></default>
       </equals>
       <equals type="string" value="multiscale">
	 <default param="scales"><value type="intArray"></value></default>
	 <default param="restoringbeam"><value type="stringArray"></value></default>
       </equals>
       <equals type="string" value="mtmfs">
	 <default param="scales"><value type="intArray"></value></default>
	 <default param="nterms"><value>2</value></default>  
	 <default param="restoringbeam"><value type="stringArray"></value></default>
       </equals>
       <equals type="string" value="aasp">
	 <default param="restoringbeam"><value type="stringArray"></value></default>
       </equals>
     </when>

     <when param="niter">
       <notequals type="int" value="0">
	 <default param="gain"><value>0.1</value></default>
	 <default param="threshold"><value>0.0</value></default>
	 <default param="cycleniter"><value>-1</value></default>
	 <default param="cyclefactor"><value>1.0</value></default>
	 <default param="minpsffraction"><value>0.05</value></default>
	 <default param="maxpsffraction"><value>0.8</value></default>
	 <default param="interactive"><value>False</value></default>
	 <default param="mask"><value>""</value></default>
<!--	 <default param="savemodel"><value>"none"</value></default>
 	 <default param="calcres"><value>True</value></default>
	 <default param="calcpsf"><value>True</value></default>  -->
       </notequals>
<!--       <equals type="int" value="0">
	 <default param="calcpsf"><value>True</value></default>
       </equals> -->
     </when>

<!--
     <when param="parallel">
       <equals type="bool" value="False">
       </equals>
       <equals type="bool" value="True">
 	 <default param="clusterdef"><value>""</value></default> 
	 <default param="workdir"><value>""</value></default> 
       </equals>
     </when>  
-->

   </constraints>

  </input>
  
  <returns type="void"/>

  <example>

     Usage Examples :

     https://svn.cv.nrao.edu/svn/casa/trunk/gcwrap/python/scripts/tests/test_refimager.py

  </example>

</task>

</casaxml>
